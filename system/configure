#!

(import (bootscheme 2020))

;; Utilities

(define (find match? lis)
  (and (not (null? lis))
       (if (match? (car lis)) (car lis)
           (find match? (cdr lis)))))

(define (find-value get-value lis)
  (and (not (null? lis))
       (let ((value (get-value (car lis))))
         (or value (find-value get-value (cdr lis))))))

(define (fold combine state lis)
  (let loop ((state state) (lis lis))
    (if (null? lis) state (loop (combine state (car lis)) (cdr lis)))))

(define (filter match? lis)
  (reverse (fold (lambda (newlis elt)
                   (if (match? elt) (cons elt newlis) newlis))
                 '() lis)))

(define (string-index s char)
  (let ((n (string-length s)))
    (let loop ((i 0))
      (cond ((= i n) #f)
            ((char=? char (string-ref s i)) i)
            (else (loop (+ i 1)))))))

(define (string-index-right s char start)
  (let loop ((i (- (string-length s) 1)))
    (cond ((< i start) #f)
          ((char=? char (string-ref s 1)) i)
          (else (loop (- i 1))))))

(define (string-join strings delimiter)
  (if (null? strings) ""
      (let loop ((acc (car strings)) (strings (cdr strings)))
        (if (null? strings) acc
            (loop (string-append acc delimiter (car strings))
                  (cdr strings))))))

(define (string-prefix? fix s)
  (and (>= (string-length s) (string-length fix))
       (string=? fix (substring s 0 (string-length fix)))))

(define (acons key val alist)
  (cons (cons key val) alist))

(define (writeln x)
  (write x)
  (newline))

(define (disp . xs)
  (for-each display xs)
  (newline))

(define (parse-version-line-from-command version-prefix command . args)
  (let ((line (apply first-line-from-command command args)))
    (and line
         (string-prefix? version-prefix line)
         (substring line
                    (string-length version-prefix)
                    (string-length line)))))

;; Option parsing

(define available-options
  '((("--help" "-h") #f "Show help")
    (("--version" "-V") #f "Show version")

    ;;

    (("--bindir")         directory "")
    (("--datadir")        directory "")
    (("--datarootdir")    directory "")
    (("--docdir")         directory "")
    (("--dvidir")         directory "")
    (("--exec-prefix")    directory "")
    (("--htmldir")        directory "")
    (("--includedir")     directory "")
    (("--infodir")        directory "")
    (("--libdir")         directory "")
    (("--libexecdir")     directory "")
    (("--localedir")      directory "")
    (("--localstatedir")  directory "")
    (("--mandir")         directory "")
    (("--oldincludedir")  directory "")
    (("--pdfdir")         directory "")
    (("--prefix")         directory "")
    (("--psdir")          directory "")
    (("--runstatedir")    directory "")
    (("--sbindir")        directory "")
    (("--sharedstatedir") directory "aa")
    (("--sysconfdir")     directory "")

    ;;

    (("--srcdir")         directory "")))

(define (option-names    option) (list-ref option 0))
(define (option-argument option) (list-ref option 1))
(define (option-helpline option) (list-ref option 2))

(define (option-by-name name)
  (or (and (find (lambda (option) (member name (car option)))
                 available-options))
      (error "No such option" name)))

(define (fatal message)
  (write-string message (current-error-port))
  (newline (current-error-port))
  (exit #f))

(define (version)
  (disp "version")
  (exit #t))

(define (generic-usage which-exit which-port)
  (parameterize ((current-output-port which-port))
    (disp "`configure' configures " progname " " progvers
          " to adapt to many kinds of systems.")
    (disp)
    (disp "Usage: ./configure [OPTION]... [VAR=VALUE]...")
    (disp)
    (disp "To assign environment variables (e.g., CC, CFLAGS...), specify them as")
    (disp "VAR=VALUE.  See below for descriptions of some of the useful variables.")
    (disp)
    (disp "Defaults for the options are specified in brackets.")
    (disp)
    (disp "Options:")
    (let* ((lines (map (lambda (option)
                         (cons (string-join (option-names option) "|")
                               (option-helpline option)))
                       available-options))
           (maxlen (fold max 0 (map string-length (map car lines)))))
      (for-each (lambda (line)
                  (let* ((gaplen (+ 3 (- maxlen (string-length (car line)))))
                         (gap (make-string gaplen #\space)))
                    (disp (car line) gap (cdr line))))
                lines))
    (exit which-exit)))

(define (usage) (generic-usage #f (current-error-port)))
(define (successful-usage) (generic-usage #t (current-output-port)))

(define (how-many-dashes s)
  (let ((n (min 3 (string-length s))))
    (let loop ((i 0))
      (if (and (< i n) (char=? #\- (string-ref s i)))
          (loop (+ i 1))
          i))))

(define (handle state name value)
  (cond ((not name)
         (error "Non-option args not supported" value))
        ((equal? name "-h")
         (acons 'help #t state))
        ((equal? name "-V")
         (acons 'version #t state))
        ((equal? name "--help")
         (acons 'help #t state))
        ((equal? name "--version")
         (acons 'version #t state))
        ((equal? name "--prefix")
         (acons 'prefix value state))
        ((equal? name "--srcdir")
         (acons 'srcdir value state))
        (else
         (error "Unknown option"))))

(define (parse-args args)
  (let loop ((state '()) (args args))
    (if (null? args) state
        (let ((arg (car args)))
          (case (how-many-dashes arg)
            ((0) (loop (handle state #f arg) (cdr args)))
            ((1) (if (= 1 (string-length arg))
                     (loop (handle state #f arg) (cdr args))
                     (let loop-singles ((state state) (args (cdr args)) (i 1))
                       (if (= i (string-length arg))
                           (loop state args)
                           (loop-singles (handle state
                                                 (string #\- (string-ref arg i))
                                                 (car args))
                                         (cdr args)
                                         (+ i 1))))))
            ((2) (if (= 2 (string-length arg))
                     (let loop-non-options ((state state) (args (cdr args)))
                       (if (null? args) state
                           (loop-non-options (handle state #f (car args))
                                             (cdr args))))
                     (let* ((pivot (string-index arg #\=))
                            (name (substring arg 0 (or pivot (string-length arg))))
                            (option (option-by-name name))
                            (argument (option-argument option))
                            (imm-val (and pivot (substring arg
                                                           (+ pivot 1)
                                                           (string-length arg))))
                            (value (if (not argument)
                                       (if imm-val
                                           (error "No argument expected")
                                           #f)
                                       (if imm-val
                                           imm-val
                                           (if (null? (cdr args))
                                               (error "No argument given")
                                               (cadr args))))))
                       (loop (handle state name value)
                             (if (or imm-val (not argument))
                                 (cdr args)
                                 (cddr args))))))
            (else (error "Too many dashes")))))))

;;

(define (write-config-status)
  (with-output-to-file "config.status"
    (lambda ()
      (disp "#! /bin/sh")
      (disp "cd \"$(dirname \"$0\")\"")
      (disp "exec ./configure --foo"))))

(define (write-makefile)
  (with-output-to-file "Makefile"
    (lambda ()
      (let ((phony-targets
             '("all"
               "install"
               "install-html"
               "install-dvi"
               "install-pdf"
               "install-ps"
               "uninstall"
               "install-strip"
               "clean"
               "distclean"
               "mostlyclean"
               "maintainer-clean"
               "TAGS"
               "info"
               "dvi"
               "html"
               "pdf"
               "ps"
               "dist"
               "check"
               "installcheck"
               "installdirs")))
        (disp ".PHONY: " (string-join phony-targets " "))))))

(define (find-srcdir srcdir-option)
  (define (dir-contains-sources? dir)
    #f)
  (or (find dir-contains-sources?
            (if srcdir-option (list srcdir-option) (list "." "..")))
      (error "cannot find the sources")))

(define progname "Gambit")
(define progvers "4.9.3")

(define (get-envars-for-c)
  (list (cons 'cc (get-environment-variable "CC"))
        (cons 'cflags (get-environment-variable "CFLAGS"))
        (cons 'ldflags (get-environment-variable "LDFLAGS"))))

(define (make-check what help written thunk)
  (list what help written thunk))

(define (check-what    check) (list-ref check 0))
(define (check-help    check) (list-ref check 1))
(define (check-written check) (list-ref check 2))
(define (check-thunk   check) (list-ref check 3))

(define (run-check check)
  (write-string "checking ")
  (write-string (check-what check))
  (write-string "... ")
  (flush-output-port (current-output-port))
  (let ((value ((check-thunk check))))
    (write-string ((check-written check) value))
    (newline)
    value))

(define (find-program-and-version version-flag prefix commands)
  (find-value (lambda (command)
                (let ((version (parse-version-line-from-command
                                prefix command version-flag)))
                  (and version (cons command version))))
              commands))

(define (command-and-versions command versions)
  (cons command
        (map (lambda (version) (string-append command "-" version))
             versions)))

(define (or-not-found value) (or value "not found"))
(define (car-or-not-found value) (if value (car value) "not found"))
(define (boolean-as-yes-or-no value) (if value "yes" "no"))

(define check-for-gnu-make
  (make-check
   "for GNU make"
   "Search all the common names for GNU make"
   car-or-not-found
   (lambda () (find-program-and-version
               "--version" "GNU Make "
               '("gmake" "make")))))

(define check-for-gcc
  (make-check
   "for gcc"
   "Search for the GNU Compiler Collection"
   car-or-not-found
   (lambda () (find-program-and-version
               "--version" "gcc-10 "
               (cons "cc" (command-and-versions "gcc" '("10")))))))

(define check-for-guile
  (make-check
   "for Guile"
   "Search for GNU Guile"
   car-or-not-found
   (lambda () (find-program-and-version
               "--version" "guile (GNU Guile)"
               (command-and-versions "guile" '("2.2" "2.0" "1.8"))))))

;; (define (ac-define variable-name true-value help) #f)
;;
;; (when (string-contains out key)
;;   (ac-define "HAVE_INT128" "1" "Define to 1 if you have the type __int128."))

(define (run-c-preprocessor . lines)
  (let ((temp-file-name "configure-temp.c"))
    (with-output-to-file temp-file-name
      (lambda () (for-each write-line lines)))
    (all-output-from-command "cc" "-E" temp-file-name)))

(define check-for-c-int128
  (make-check
   "for __int128"
   "Check for __int128"
   boolean-as-yes-or-no
   (lambda ()
     (let* ((key "Found it")
            (out (run-c-preprocessor
                  "#ifdef __SIZEOF_INT128__"
                  key
                  "#endif")))
       (not (not (string-contains out key)))))))

(define (configure args)
  (let ((state (parse-args args)))
    (cond ((assoc 'help state)
           (successful-usage))
          ((assoc 'version state)
           (version))
          (else
           (run-check check-for-gnu-make)
           (run-check check-for-gcc)
           (run-check check-for-guile)
           (run-check check-for-c-int128)
           (write-makefile)
           (write-config-status)))))

(define (make args)
  #f)

(define (which-command)
  (let ((name (command-name)))
    (cond ((equal? name "configure") configure)
          ((equal? name "make") make)
          (else (error "Unknown command" name)))))

(define (main)
  (let ((command (which-command)))
    (command (command-args))))

(main)
